import argparse
import json
import multiprocessing
import os
import random
import re
from glob import glob
from time import time

import mne
import numpy as np
import pandas as pd
import scipy
import scipy.io as sio
import skimage

# import pyfftw
from h5py import File

# from numba import jit

# from mkl_fft._scipy_fft import fft
# from mkl_fft._scipy_fft import fftshift
# from mkl_fft._scipy_fft import ifft
# from mkl_fft._scipy_fft import irfft
# from numpy.fft import fft
# from numpy.fft import fftshift
# from numpy.fft import ifft
# from numpy.fft import irfft
# from pyedflib import highlevel
from scipy import signal
from scipy.fft import fft
from scipy.fft import fftshift
from scipy.fft import ifft
from scipy.fft import irfft
from tqdm import tqdm

# from pyfftw.interfaces.scipy_fft import fft
# from pyfftw.interfaces.scipy_fft import fftshift
# from pyfftw.interfaces.scipy_fft import ifft
# from pyfftw.interfaces.scipy_fft import irfft

from utils import edf_read_fns
from utils import load_scored_data
from utils.errors import MissingHypnogramError
from utils.errors import MissingSignalsError
from utils.errors import ReferencingError

os.chdir("/home/users/alexno/sleep-staging")
nthread = multiprocessing.cpu_count()

# random.seed(1337)

cc_sizes = [2, 2, 4, 4, 0.4]
cc_overlap = 0.25

# filter_specs = {
#     100: {
#         512: {'up': 1, 'down': 4, 'numerator': [-0.022060946491163, 0, 0.052883465855856, 0.137204845287131, 0.217078297765917, 0.250000000000000, 0.217078297765917, 0.137204845287131, 0.052883465855856, 0, -0.022060946491163]},
#         500: {'up': 1, 'down': 5, 'numerator': [-0.0175636017706537, -0.0208207236911009, -0.0186368912579407, 0.0, 0.0376532652007562, 0.0894912177899215, 0.143586518157187, 0.184663795586300, 0.200000000000000, 0.184663795586300, 0.143586518157187, 0.0894912177899215, 0.0376532652007562, 0.0, -0.0186368912579407, -0.0208207236911009, -0.0175636017706537]},
#         256: {'up': 1, 'down': 2, 'numerator': [-0.0417399210251745, 0, 0.289846976954388, 0.500000000000000, 0.289846976954388, 0, -0.0417399210251745]},
#         200: {'up': 1, 'down': 2, 'numerator': [-0.050624178425469, 0.0, 0.295059334702992, 0.500000000000000, 0.295059334702992, 0.0, -0.050624178425469]},
#         128: {'up': 25, 'down': 32, 'numerator': [-0.0501717842426216, -0.0556760119714998, -0.0610307762097263, -0.0661283610354292, -0.0708548073010700, -0.0750910436246355, -0.0787141428918385, -0.0815986914952349, -0.0836182565021119, -0.0846469340736065, -0.0845609607846693, -0.0832403680477313, -0.0805706586488326, -0.0764444834867697, -0.0707632959829281, -0.0634389613171646, -0.0543952976542141, -0.0435695268617284, -0.0309136128865135, -0.0163954669461123, 0, 0.0182699954252339, 0.0383931500874757, 0.0603290234313986, 0.0840178210236961, 0.109380332907679, 0.136318098998248, 0.164713804740471, 0.194431907264671, 0.225319489229560, 0.257207334495584, 0.289911216756529, 0.323233389322187, 0.356964261431120, 0.390884243821665, 0.424765743840790, 0.458375288160870, 0.491475749237731, 0.523828650009171, 0.555196520027502, 0.585345275263576, 0.614046593229554, 0.641080254854336, 0.666236424714809, 0.689317841777958, 0.710141893738048, 0.728542549328591, 0.744372124634465, 0.757502861403933, 0.767828297637239, 0.775264413277317, 0.779750536614209, 0.781250000000000, 0.779750536614209, 0.775264413277317, 0.767828297637239, 0.757502861403933, 0.744372124634465, 0.728542549328591, 0.710141893738048, 0.689317841777958, 0.666236424714809, 0.641080254854336, 0.614046593229554, 0.585345275263576, 0.555196520027502, 0.523828650009171, 0.491475749237731, 0.458375288160870, 0.424765743840790, 0.390884243821665, 0.356964261431120, 0.323233389322187, 0.289911216756529, 0.257207334495584, 0.225319489229560, 0.194431907264671, 0.164713804740471, 0.136318098998248, 0.109380332907679, 0.0840178210236961, 0.0603290234313986, 0.0383931500874757, 0.0182699954252339, 0, -0.0163954669461123, -0.0309136128865135, -0.0435695268617284, -0.0543952976542141, -0.0634389613171646, -0.0707632959829281, -0.0764444834867697, -0.0805706586488326, -0.0832403680477313, -0.0845609607846693, -0.0846469340736065, -0.0836182565021119, -0.0815986914952349, -0.0787141428918385, -0.0750910436246355, -0.0708548073010700, -0.0661283610354292, -0.0610307762097263, -0.0556760119714998, -0.0501717842426216]},
#         64: {'up': 25, 'down': 16, 'numerator': [-0.0320893507939845, -0.0344139808620806, -0.0362877971368454, -0.0376420994987445, -0.0384136008594217, -0.0385459881687820, -0.0379914348015759, -0.0367120329513975, -0.0346811148078800, -0.0318844320359302, -0.0283211644203699, -0.0240047304804672, -0.0189633753803122, -0.0132405145352462, -0.00689481490285626, 0, 0.00735563085459690, 0.0150699737780891, 0.0230281816934504, 0.0311040102536598, 0.0391614374261428, 0.0470565405346993, 0.0546396093506209, 0.0617574688192032, 0.0682559802981444, 0.0739826858634525, 0.0787895563949266, 0.0825358008693668, 0.0850906916397958, 0.0863363585281994, 0.0861705033618723, 0.0845089861816643, 0.0812882347735018, 0.0764674304379452, 0.0700304250172251, 0.0619873471314706, 0.0523758593071541, 0.0412620321679860, 0.0287408070443068, 0.0149360241707093, 0, -0.0158873560297387, -0.0325198877835292, -0.0496669968935155, -0.0670758930155576, -0.0844742700003676, -0.101573380739946, -0.118071476348402, -0.133657568617852, -0.148015468474627, -0.160828047561907, -0.171781665197169, -0.180570698891262, -0.186902113453400, -0.190500001511837, -0.191110027107665, -0.188503703906869, -0.182482440544383, -0.172881287666473, -0.159572324359673, -0.142467625812865, -0.121521759203632, -0.0967337608632991, -0.0681485546737065, -0.0358577792844161, 0, 0.0392397100499735, 0.0816308257137906, 0.126899059488686, 0.174728672513159, 0.224765384957634, 0.276619854730678, 0.329871684621280, 0.384073909707119, 0.438757909210108, 0.493438680100573, 0.547620403755472, 0.600802231965954, 0.652484214652076, 0.702173288847600, 0.749389246917535, 0.793670601598622, 0.834580266321688, 0.871710971378531, 0.904690339808223, 0.933185551352875, 0.956907528406173, 0.975614584466860, 0.989115483114800, 0.997271863835223, 1, 0.997271863835223, 0.989115483114800, 0.975614584466860, 0.956907528406173, 0.933185551352875, 0.904690339808223, 0.871710971378531, 0.834580266321688, 0.793670601598622, 0.749389246917535, 0.702173288847600, 0.652484214652076, 0.600802231965954, 0.547620403755472, 0.493438680100573, 0.438757909210108, 0.384073909707119, 0.329871684621280, 0.276619854730678, 0.224765384957634, 0.174728672513159, 0.126899059488686, 0.0816308257137906, 0.0392397100499735, 0, -0.0358577792844161, -0.0681485546737065, -0.0967337608632991, -0.121521759203632, -0.142467625812865, -0.159572324359673, -0.172881287666473, -0.182482440544383, -0.188503703906869, -0.191110027107665, -0.190500001511837, -0.186902113453400, -0.180570698891262, -0.171781665197169, -0.160828047561907, -0.148015468474627, -0.133657568617852, -0.118071476348402, -0.101573380739946, -0.0844742700003676, -0.0670758930155576, -0.0496669968935155, -0.0325198877835292, -0.0158873560297387, 0, 0.0149360241707093, 0.0287408070443068, 0.0412620321679860, 0.0523758593071541, 0.0619873471314706, 0.0700304250172251, 0.0764674304379452, 0.0812882347735018, 0.0845089861816643, 0.0861705033618723, 0.0863363585281994, 0.0850906916397958, 0.0825358008693668, 0.0787895563949266, 0.0739826858634525, 0.0682559802981444, 0.0617574688192032, 0.0546396093506209, 0.0470565405346993, 0.0391614374261428, 0.0311040102536598, 0.0230281816934504, 0.0150699737780891, 0.00735563085459690, 0, -0.00689481490285626, -0.0132405145352462, -0.0189633753803122, -0.0240047304804672, -0.0283211644203699, -0.0318844320359302, -0.0346811148078800, -0.0367120329513975, -0.0379914348015759, -0.0385459881687820, -0.0384136008594217, -0.0376420994987445, -0.0362877971368454, -0.0344139808620806, -0.0320893507939845]},
#     },
#     128: {
#         512: {'up': 1, 'down': 4, 'numerator': [-0.0220609464911632, 0, 0.0528834658558560, 0.137204845287131, 0.217078297765917, 0.250000000000000, 0.217078297765917, 0.137204845287131, 0.0528834658558560, 0, -0.0220609464911632]},
#         500: {'up': 32, 'down': 125, 'numerator': [-0.0186277509643056, -0.0187784782864694, -0.0189111789766638, -0.0190250810445174, -0.0191194122495175, -0.0191934008258555, -0.0192462762158576, -0.0192772698113379, -0.0192856157021927, -0.0192705514315450, -0.0192313187567333, -0.0191671644154287, -0.0190773408961504, -0.0189611072124433, -0.0188177296799682, -0.0186464826957473, -0.0184466495187999, -0.0182175230513951, -0.0179584066201427, -0.0176686147561355, -0.0173474739733540, -0.0169943235445376, -0.0166085162737250, -0.0161894192646630, -0.0157364146842809, -0.0152489005204278, -0.0147262913330692, -0.0141680189981413, -0.0135735334432602, -0.0129423033744915, -0.0122738169933820, -0.0115675827034656, -0.0108231298054576, -0.0100400091803580, -0.00921779395969223, -0.00835608018212528, -0.00745448743569246, -0.00651265948490202, -0.00553026488197292, -0.00450699756148354, -0.00344257741771889, -0.00233675086401630, -0.00118929137342389, 0, 0.00123129411990248, 0.00250473328700737, 0.00382043077976551, 0.00517847041688979, 0.00657890614236300, 0.00802176163348671, 0.00950702993252058, 0.0110346731024403, 0.0126046219073222, 0.0142167755178400, 0.0158710012423373, 0.0175671342839172, 0.0193049775239655, 0.0210843013325009, 0.0229048434057215, 0.0247663086310898, 0.0266683689802762, 0.0286106634302515, 0.0305927979127944, 0.0326143452926534, 0.0346748453745742, 0.0367738049393768, 0.0389106978092386, 0.0410849649423112, 0.0432960145567708, 0.0455432222843734, 0.0478259313535567, 0.0501434528021009, 0.0524950657193346, 0.0548800175178374, 0.0572975242345675, 0.0597467708613079, 0.0622269117042990, 0.0647370707728944, 0.0672763421970470, 0.0698437906734045, 0.0724384519397636, 0.0750593332776027, 0.0777054140423848, 0.0803756462212930, 0.0830689550180338, 0.0857842394643126, 0.0885203730575620, 0.0912762044244720, 0.0940505580098462, 0.0968422347902806, 0.0996500130121371, 0.102472648953253, 0.105308877707810, 0.108157413993752, 0.111016952982126, 0.113886171147688, 0.116763727140104, 0.119648262675032, 0.122538403444383, 0.125432760044994, 0.128329928924977, 0.131228493346930, 0.134127024367235, 0.137024081830600, 0.139918215379020, 0.142807965474289, 0.145691864433209, 0.148568437474583, 0.151436203777121, 0.154293677547313, 0.157139369096365, 0.159971785925251, 0.162789433816925, 0.165590817934740, 0.168374443926110, 0.171138819030420, 0.173882453190226, 0.176603860164731, 0.179301558644561, 0.181974073366835, 0.184619936229518, 0.187237687404080, 0.189825876445426, 0.192383063398110, 0.194907819897831, 0.197398730267202, 0.199854392604794, 0.202273419866466, 0.204654440937993, 0.206996101698001, 0.209297066070240, 0.211556017064224, 0.213771657803284, 0.215942712539080, 0.218067927651634, 0.220146072633966, 0.222175941060417, 0.224156351537748, 0.226086148638157, 0.227964203813319, 0.229789416288616, 0.231560713936717, 0.233277054129684, 0.234937424568826, 0.236540844091503, 0.238086363454149, 0.239573066090746, 0.241000068846082, 0.242366522683055, 0.243671613363406, 0.244914562101198, 0.246094626188461, 0.247211099592388, 0.248263313523538, 0.249250636974493, 0.250172477228477, 0.251028280337450, 0.251817531569211, 0.252539755823124, 0.253194518014029, 0.253781423424011, 0.254300118021676, 0.254750288748634, 0.255131663772926, 0.255444012709140, 0.255687146805023, 0.255860919094406, 0.255965224516291, 0.256000000000000, 0.255965224516291, 0.255860919094406, 0.255687146805023, 0.255444012709140, 0.255131663772926, 0.254750288748634, 0.254300118021676, 0.253781423424011, 0.253194518014029, 0.252539755823124, 0.251817531569211, 0.251028280337450, 0.250172477228477, 0.249250636974493, 0.248263313523538, 0.247211099592388, 0.246094626188461, 0.244914562101198, 0.243671613363406, 0.242366522683055, 0.241000068846082, 0.239573066090746, 0.238086363454149, 0.236540844091503, 0.234937424568826, 0.233277054129684, 0.231560713936717, 0.229789416288616, 0.227964203813319, 0.226086148638157, 0.224156351537748, 0.222175941060417, 0.220146072633966, 0.218067927651634, 0.215942712539080, 0.213771657803284, 0.211556017064224, 0.209297066070240, 0.206996101698001, 0.204654440937993, 0.202273419866466, 0.199854392604794, 0.197398730267202, 0.194907819897831, 0.192383063398110, 0.189825876445426, 0.187237687404080, 0.184619936229518, 0.181974073366835, 0.179301558644561, 0.176603860164731, 0.173882453190226, 0.171138819030420, 0.168374443926110, 0.165590817934740, 0.162789433816925, 0.159971785925251, 0.157139369096365, 0.154293677547313, 0.151436203777121, 0.148568437474583, 0.145691864433209, 0.142807965474289, 0.139918215379020, 0.137024081830600, 0.134127024367235, 0.131228493346930, 0.128329928924977, 0.125432760044994, 0.122538403444383, 0.119648262675032, 0.116763727140104, 0.113886171147688, 0.111016952982126, 0.108157413993752, 0.105308877707810, 0.102472648953253, 0.0996500130121371, 0.0968422347902806, 0.0940505580098462, 0.0912762044244720, 0.0885203730575620, 0.0857842394643126, 0.0830689550180338, 0.0803756462212930, 0.0777054140423848, 0.0750593332776027, 0.0724384519397636, 0.0698437906734045, 0.0672763421970470, 0.0647370707728944, 0.0622269117042990, 0.0597467708613079, 0.0572975242345675, 0.0548800175178374, 0.0524950657193346, 0.0501434528021009, 0.0478259313535567, 0.0455432222843734, 0.0432960145567708, 0.0410849649423112, 0.0389106978092386, 0.0367738049393768, 0.0346748453745742, 0.0326143452926534, 0.0305927979127944, 0.0286106634302515, 0.0266683689802762, 0.0247663086310898, 0.0229048434057215, 0.0210843013325009, 0.0193049775239655, 0.0175671342839172, 0.0158710012423373, 0.0142167755178400, 0.0126046219073222, 0.0110346731024403, 0.00950702993252058, 0.00802176163348671, 0.00657890614236300, 0.00517847041688979, 0.00382043077976551, 0.00250473328700737, 0.00123129411990248, 0, -0.00118929137342389, -0.00233675086401630, -0.00344257741771889, -0.00450699756148354, -0.00553026488197292, -0.00651265948490202, -0.00745448743569246, -0.00835608018212528, -0.00921779395969223, -0.0100400091803580, -0.0108231298054576, -0.0115675827034656, -0.0122738169933820, -0.0129423033744915, -0.0135735334432602, -0.0141680189981413, -0.0147262913330692, -0.0152489005204278, -0.0157364146842809, -0.0161894192646630, -0.0166085162737250, -0.0169943235445376, -0.0173474739733540, -0.0176686147561355, -0.0179584066201427, -0.0182175230513951, -0.0184466495187999, -0.0186464826957473, -0.0188177296799682, -0.0189611072124433, -0.0190773408961504, -0.0191671644154287, -0.0192313187567333, -0.0192705514315450, -0.0192856157021927, -0.0192772698113379, -0.0192462762158576, -0.0191934008258555, -0.0191194122495175, -0.0190250810445174, -0.0189111789766638, -0.0187784782864694, -0.0186277509643056]},
#         256: {'up': 1, 'down': 2, 'numerator': [-0.0417399210251745, 0, 0.289846976954388, 0.500000000000000, 0.289846976954388, 0, -0.0417399210251745]},
#         200: {'up': 16, 'down': 25, 'numerator': [-0.0436462751891287, -0.0464412069276776, -0.0482437247384815, -0.0488155232373854, -0.0479191617389486, -0.0453238327625464, -0.0408113304721892, -0.0341820751773843, -0.0252610426777502, -0.0139034437840865, 0, 0.0165183338049654, 0.0356763398813007, 0.0574513283484721, 0.0817708584966123, 0.108511480722484, 0.137498566055392, 0.168507264753285, 0.201264608268938, 0.235452740704524, 0.270713237434087, 0.306652440640183, 0.342847714844178, 0.378854500845945, 0.414214024519381, 0.448461498261203, 0.481134638103778, 0.511782309020223, 0.539973105099731, 0.565303670257620, 0.587406569041528, 0.605957525842768, 0.620681864227299, 0.631359995843137, 0.637831829999643, 0.640000000000000, 0.637831829999643, 0.631359995843137, 0.620681864227299, 0.605957525842768, 0.587406569041528, 0.565303670257620, 0.539973105099731, 0.511782309020223, 0.481134638103778, 0.448461498261203, 0.414214024519381, 0.378854500845945, 0.342847714844178, 0.306652440640183, 0.270713237434087, 0.235452740704524, 0.201264608268938, 0.168507264753285, 0.137498566055392, 0.108511480722484, 0.0817708584966123, 0.0574513283484721, 0.0356763398813007, 0.0165183338049654, 0, -0.0139034437840865, -0.0252610426777502, -0.0341820751773843, -0.0408113304721892, -0.0453238327625464, -0.0479191617389486, -0.0488155232373854, -0.0482437247384815, -0.0464412069276776, -0.0436462751891287]},
#         100: {'up': 32, 'down': 25, 'numerator': [-0.0642198838305557, -0.0712652953235198, -0.0781193935484496, -0.0846443021253494, -0.0906941533453696, -0.0961165358395334, -0.100754102901553, -0.104446325113901, -0.107031368322703, -0.108348075614216, -0.108238029804377, -0.106547671101096, -0.103130443070506, -0.0978489388630653, -0.0905770188581479, -0.0812018704859708, -0.0696259809973940, -0.0557689943830124, -0.0395694244947373, -0.0209861976910238, 0, 0.0233855941442993, 0.0491432321119689, 0.0772211499921902, 0.107542810910331, 0.140006826121830, 0.174487166717757, 0.210833670067803, 0.248872841298779, 0.288408946213837, 0.329225388154348, 0.371086357448357, 0.413738738332399, 0.456914254631833, 0.500331832091731, 0.543700152116211, 0.586720368845913, 0.629088959024296, 0.670500672011739, 0.710651545635202, 0.749241952337377, 0.785979639333829, 0.820582726213551, 0.852782623634956, 0.882326837475786, 0.908981623984701, 0.932534463140596, 0.952796319532115, 0.969603662597034, 0.982820220975666, 0.992338448994966, 0.998080686866188, 1, 0.998080686866188, 0.992338448994966, 0.982820220975666, 0.969603662597034, 0.952796319532115, 0.932534463140596, 0.908981623984701, 0.882326837475786, 0.852782623634956, 0.820582726213551, 0.785979639333829, 0.749241952337377, 0.710651545635202, 0.670500672011739, 0.629088959024296, 0.586720368845913, 0.543700152116211, 0.500331832091731, 0.456914254631833, 0.413738738332399, 0.371086357448357, 0.329225388154348, 0.288408946213837, 0.248872841298779, 0.210833670067803, 0.174487166717757, 0.140006826121830, 0.107542810910331, 0.0772211499921902, 0.0491432321119689, 0.0233855941442993, 0, -0.0209861976910238, -0.0395694244947373, -0.0557689943830124, -0.0696259809973940, -0.0812018704859708, -0.0905770188581479, -0.0978489388630653, -0.103130443070506, -0.106547671101096, -0.108238029804377, -0.108348075614216, -0.107031368322703, -0.104446325113901, -0.100754102901553, -0.0961165358395334, -0.0906941533453696, -0.0846443021253494, -0.0781193935484496, -0.0712652953235198, -0.0642198838305557]},
#         64: {'up': 2, 'down': 1, 'numerator': [-0.0450613351820339, 0, 0.0837738835826994, 0, -0.183632917006313, 0, 0.626677299892008, 1, 0.626677299892008, 0, -0.183632917006313, 0, 0.0837738835826994, 0, -0.0450613351820339]},
#     }
# }
# filter_specs = {
#     512: {'up': 1, 'down': 4, 'numerator': [-0.022060946491163, 0, 0.052883465855856, 0.137204845287131, 0.217078297765917, 0.250000000000000, 0.217078297765917, 0.137204845287131, 0.052883465855856, 0, -0.022060946491163]},
#     500: {'up': 1, 'down': 5, 'numerator': [-0.0175636017706537, -0.0208207236911009, -0.0186368912579407, 0.0, 0.0376532652007562, 0.0894912177899215, 0.143586518157187, 0.184663795586300, 0.200000000000000, 0.184663795586300, 0.143586518157187, 0.0894912177899215, 0.0376532652007562, 0.0, -0.0186368912579407, -0.0208207236911009, -0.0175636017706537]},
#     256: {'up': 1, 'down': 2, 'numerator': [-0.0417399210251745, 0, 0.289846976954388, 0.500000000000000, 0.289846976954388, 0, -0.0417399210251745]},
#     200: {'up': 1, 'down': 2, 'numerator': [-0.050624178425469, 0.0, 0.295059334702992, 0.500000000000000, 0.295059334702992, 0.0, -0.050624178425469]},
#     128: {'up': 25, 'down': 32, 'numerator': [-0.0501717842426216, -0.0556760119714998, -0.0610307762097263, -0.0661283610354292, -0.0708548073010700, -0.0750910436246355, -0.0787141428918385, -0.0815986914952349, -0.0836182565021119, -0.0846469340736065, -0.0845609607846693, -0.0832403680477313, -0.0805706586488326, -0.0764444834867697, -0.0707632959829281, -0.0634389613171646, -0.0543952976542141, -0.0435695268617284, -0.0309136128865135, -0.0163954669461123, 0, 0.0182699954252339, 0.0383931500874757, 0.0603290234313986, 0.0840178210236961, 0.109380332907679, 0.136318098998248, 0.164713804740471, 0.194431907264671, 0.225319489229560, 0.257207334495584, 0.289911216756529, 0.323233389322187, 0.356964261431120, 0.390884243821665, 0.424765743840790, 0.458375288160870, 0.491475749237731, 0.523828650009171, 0.555196520027502, 0.585345275263576, 0.614046593229554, 0.641080254854336, 0.666236424714809, 0.689317841777958, 0.710141893738048, 0.728542549328591, 0.744372124634465, 0.757502861403933, 0.767828297637239, 0.775264413277317, 0.779750536614209, 0.781250000000000, 0.779750536614209, 0.775264413277317, 0.767828297637239, 0.757502861403933, 0.744372124634465, 0.728542549328591, 0.710141893738048, 0.689317841777958, 0.666236424714809, 0.641080254854336, 0.614046593229554, 0.585345275263576, 0.555196520027502, 0.523828650009171, 0.491475749237731, 0.458375288160870, 0.424765743840790, 0.390884243821665, 0.356964261431120, 0.323233389322187, 0.289911216756529, 0.257207334495584, 0.225319489229560, 0.194431907264671, 0.164713804740471, 0.136318098998248, 0.109380332907679, 0.0840178210236961, 0.0603290234313986, 0.0383931500874757, 0.0182699954252339, 0, -0.0163954669461123, -0.0309136128865135, -0.0435695268617284, -0.0543952976542141, -0.0634389613171646, -0.0707632959829281, -0.0764444834867697, -0.0805706586488326, -0.0832403680477313, -0.0845609607846693, -0.0846469340736065, -0.0836182565021119, -0.0815986914952349, -0.0787141428918385, -0.0750910436246355, -0.0708548073010700, -0.0661283610354292, -0.0610307762097263, -0.0556760119714998, -0.0501717842426216]},
#     64: {'up': 25, 'down': 16, 'numerator': [-0.0320893507939845, -0.0344139808620806, -0.0362877971368454, -0.0376420994987445, -0.0384136008594217, -0.0385459881687820, -0.0379914348015759, -0.0367120329513975, -0.0346811148078800, -0.0318844320359302, -0.0283211644203699, -0.0240047304804672, -0.0189633753803122, -0.0132405145352462, -0.00689481490285626, 0, 0.00735563085459690, 0.0150699737780891, 0.0230281816934504, 0.0311040102536598, 0.0391614374261428, 0.0470565405346993, 0.0546396093506209, 0.0617574688192032, 0.0682559802981444, 0.0739826858634525, 0.0787895563949266, 0.0825358008693668, 0.0850906916397958, 0.0863363585281994, 0.0861705033618723, 0.0845089861816643, 0.0812882347735018, 0.0764674304379452, 0.0700304250172251, 0.0619873471314706, 0.0523758593071541, 0.0412620321679860, 0.0287408070443068, 0.0149360241707093, 0, -0.0158873560297387, -0.0325198877835292, -0.0496669968935155, -0.0670758930155576, -0.0844742700003676, -0.101573380739946, -0.118071476348402, -0.133657568617852, -0.148015468474627, -0.160828047561907, -0.171781665197169, -0.180570698891262, -0.186902113453400, -0.190500001511837, -0.191110027107665, -0.188503703906869, -0.182482440544383, -0.172881287666473, -0.159572324359673, -0.142467625812865, -0.121521759203632, -0.0967337608632991, -0.0681485546737065, -0.0358577792844161, 0, 0.0392397100499735, 0.0816308257137906, 0.126899059488686, 0.174728672513159, 0.224765384957634, 0.276619854730678, 0.329871684621280, 0.384073909707119, 0.438757909210108, 0.493438680100573, 0.547620403755472, 0.600802231965954, 0.652484214652076, 0.702173288847600, 0.749389246917535, 0.793670601598622, 0.834580266321688, 0.871710971378531, 0.904690339808223, 0.933185551352875, 0.956907528406173, 0.975614584466860, 0.989115483114800, 0.997271863835223, 1, 0.997271863835223, 0.989115483114800, 0.975614584466860, 0.956907528406173, 0.933185551352875, 0.904690339808223, 0.871710971378531, 0.834580266321688, 0.793670601598622, 0.749389246917535, 0.702173288847600, 0.652484214652076, 0.600802231965954, 0.547620403755472, 0.493438680100573, 0.438757909210108, 0.384073909707119, 0.329871684621280, 0.276619854730678, 0.224765384957634, 0.174728672513159, 0.126899059488686, 0.0816308257137906, 0.0392397100499735, 0, -0.0358577792844161, -0.0681485546737065, -0.0967337608632991, -0.121521759203632, -0.142467625812865, -0.159572324359673, -0.172881287666473, -0.182482440544383, -0.188503703906869, -0.191110027107665, -0.190500001511837, -0.186902113453400, -0.180570698891262, -0.171781665197169, -0.160828047561907, -0.148015468474627, -0.133657568617852, -0.118071476348402, -0.101573380739946, -0.0844742700003676, -0.0670758930155576, -0.0496669968935155, -0.0325198877835292, -0.0158873560297387, 0, 0.0149360241707093, 0.0287408070443068, 0.0412620321679860, 0.0523758593071541, 0.0619873471314706, 0.0700304250172251, 0.0764674304379452, 0.0812882347735018, 0.0845089861816643, 0.0861705033618723, 0.0863363585281994, 0.0850906916397958, 0.0825358008693668, 0.0787895563949266, 0.0739826858634525, 0.0682559802981444, 0.0617574688192032, 0.0546396093506209, 0.0470565405346993, 0.0391614374261428, 0.0311040102536598, 0.0230281816934504, 0.0150699737780891, 0.00735563085459690, 0, -0.00689481490285626, -0.0132405145352462, -0.0189633753803122, -0.0240047304804672, -0.0283211644203699, -0.0318844320359302, -0.0346811148078800, -0.0367120329513975, -0.0379914348015759, -0.0385459881687820, -0.0384136008594217, -0.0376420994987445, -0.0362877971368454, -0.0344139808620806, -0.0320893507939845]},
# }

try:
    df = pd.read_csv("overview_file_cohortsEM-ling1.csv")
except:
    df = pd.read_csv("data_master.csv")

noiseM = sio.loadmat("preprocessing/noiseM.mat", squeeze_me=True, mat_dtype=False)["noiseM"]
meanV = noiseM["meanV"].item()
covM = noiseM["covM"].item()

# Filter specifications for resampling from MATLAB
with open("utils/filter_coefficients/filter_specs.json", "r") as json_file:
    filter_specs = json.load(json_file)

with open("utils/channel_dicts/channel_names.txt", "r") as txt_file:
    ch_names = [re.split(", ", line.rstrip()) for line in txt_file]

def get_quiet_channel(channels, fs, meanV, covM):
    noise = np.zeros(len(channels))
    for idx, ch in enumerate(channels):
        noise[idx] = channel_noise_level(ch, fs, meanV, covM)
    return np.argmin(noise)


def channel_noise_level(channel, fs, meanV, covM):
    if isinstance(channel, np.ndarray):
        hjorth = extract_hjorth(channel, fs)
        noise_vec = np.zeros(hjorth.shape[1])
        for k in range(len(noise_vec)):
            M = hjorth[:, k][:, np.newaxis]
            x = M - meanV[:, np.newaxis]
            sigma = np.linalg.inv(covM)
            noise_vec[k] = np.sqrt(np.dot(np.dot(np.transpose(x), sigma), x))
        return np.mean(noise_vec)
    else:
        return np.inf

def get_alternative_names(ch, labels):

    for d in ch_names[ch]:
        synonym = [d == l for l in labels]
        if sum(synonym) > 0:
            break

    return synonym


# Use 5 minute sliding window.
def extract_hjorth(x, fs, dim=5 * 60, slide=5 * 60):

    # Length of first dimension
    dim = dim * fs

    # Overlap of segments in samples
    slide = slide * fs

    # Creates 2D array of overlapping segments
    # D = skimage.util.view_as_windows(x, dim, dim).T
    D = rolling_window_nodelay(x, dim, dim)
    D = np.delete(D, -1, axis=-1)

    # Extract Hjorth params for each segment
    dD = np.diff(D, 1, axis=0)
    ddD = np.diff(dD, 1, axis=0)
    mD2 = np.mean(D ** 2, axis=0)
    mdD2 = np.mean(dD ** 2, axis=0)
    mddD2 = np.mean(ddD ** 2, axis=0)

    top = np.sqrt(np.divide(mddD2, mdD2 + np.finfo(float).eps))

    mobility = np.sqrt(np.divide(mdD2, mD2 + np.finfo(float).eps))
    activity = mD2
    complexity = np.divide(top, mobility + np.finfo(float).eps)

    hjorth = np.array([activity, complexity, mobility])
    hjorth = np.log(hjorth + np.finfo(float).eps)
    return hjorth


def rolling_window_nodelay(vec, window, step):
    def calculate_padding(vec, window, step):
        import math

        N = len(vec)
        B = math.ceil(N / step)
        L = (B - 1) * step + window
        return L - N

    from skimage.util import view_as_windows

    pad = calculate_padding(vec, window, step)
    A = view_as_windows(np.pad(vec, (0, pad)), window, step).T
    zero_cols = pad // step
    return np.delete(A, np.arange(A.shape[1] - zero_cols, A.shape[1]), axis=1)


# @jit(nopython=True, parallel=True)
# @jit(nopython=True)
def encode_data(x1, x2, dim, slide, fs):

    # Length of the first dimension and overlap of segments
    dim = int(fs * dim)
    slide = int(fs * slide)

    # Create 2D array of overlapping segments
    zero_vec = np.zeros(dim // 2).astype(np.float32)
    input2 = np.concatenate((zero_vec, x2, zero_vec))
    D1 = rolling_window_nodelay(x1, dim, slide)
    D2 = rolling_window_nodelay(input2, dim * 2, slide)
    zero_mat = np.zeros((dim // 2, D1.shape[1]))
    D1 = np.concatenate([zero_mat, D1, zero_mat])

    keep_dims = D1.shape[1]
    D2 = D2[:, :keep_dims]
    D1 = D1[:, :keep_dims]

    # Fast implementation of auto/cross-correlation
    # while True:
    #     start = time()
    C = fftshift(
        np.real(
            ifft(
                fft(D1, dim * 2 - 1, axis=0, workers=-1) * np.conj(fft(D2, dim * 2 - 1, axis=0, workers=-1)),
                axis=0,
                workers=-2,
            )
        ),
        axes=0,
    ).astype(dtype=np.float32)
    # print(time() - start)
    # break
    # end1 = time() - start

    # while True:
    #     start = time()
    #     D = scipy.fft.fft(D1, dim * 2 - 1, axis=0, workers=-1)
    #     end = time() - start
    #     print(end)
    #     break
    # while True:
    #     start = time()
    #     D = pyfftw.interfaces.scipy_fft.fft(D1, dim * 2 - 1, axis=0, workers=nthread)
    #     end = time() - start
    #     break
    # print(end)

    # PYFFTW TEST
    # while True:
    #     pyfftw.forget_wisdom()
    #     start = time()
    #     # a = pyfftw.empty_aligned((dim * 2 - 1, D1.shape[1]), dtype='complex128')
    #     # a[:] = D1[:dim * 2 -1, :]
    #     # b = pyfftw.empty_aligned(a.shape, dtype='complex128')
    #     b = np.zeros(a.shape, dtype='complex128')
    #     fft_obj = pyfftw.builders.fft(D1[:dim * 2 - 1, :], axis=0, n=dim * 2 - 1, overwrite_input=False, planner_effort='FFTW_MEASURE', threads=20, auto_align_input=False, auto_contiguous=False, avoid_copy=True)
    #     b = fft_obj()
    #     end = time() - start
    #     break
    # while True:
    #     pyfftw.forget_wisdom()
    #     start = time()
    #     a = pyfftw.empty_aligned((dim * 2 - 1, D1.shape[1]), dtype='complex128')
    #     a[:] = D1[:dim * 2 -1, :]
    #     b = pyfftw.empty_aligned(a.shape, dtype='complex128')
    #     fft_obj = pyfftw.FFTW(a, b, axes=(0,), direction='FFTW_FORWARD', flags=('FFTW_MEASURE', ), threads=5, planning_timelimit=None )
    #     fft_obj()
    #     end = time() - start
    #     break
    # while True:
    #     pyfftw.forget_wisdom()
    #     start = time()
    #     a = pyfftw.empty_aligned((D1.shape), dtype='float64')
    #     a[:] = D1
    #     b = pyfftw.empty_aligned((D1.shape[0] // 2 + 1, D1.shape[1]), dtype='complex128')
    #     fft_obj = pyfftw.FFTW(a, b, axes=(0,), direction='FFTW_FORWARD', flags=('FFTW_MEASURE', ), threads=5, planning_timelimit=None )
    #     fft_obj()
    #     end = time() - start
    #     break
    # while True:
    #     pyfftw.forget_wisdom()
    #     start = time()
    #     # a = pyfftw.empty_aligned((D1.shape), dtype='float64')
    #     # a[:] = D1
    #     b = np.zeros(D1.shape[:]).astype(np.complex128)
    #     fft_obj = pyfftw.builders.fft(D1, axis=0, n=dim * 2 - 1, threads=10, planner_effort='FFTW_MEASURE', overwrite_input=False, auto_align_input=False, auto_contiguous=False)
    #     b = fft_obj()
    #     end = time() - start
    #     break
    #     fft_fn = pyfftw.FFTW(D1, D, axis=0, direction='FFTW_FORWARD', flags=('FFTW_MEASURE', ), threads=5, planning_timelimit=None )
    #     fft_fn()
    #     # D = scipy.fft.fft(D1, dim * 2 - 1, axis=0)
    #     end = time() - start
    #     print(end)
    #     break
    # while True:
    #     start = time()
    #     c1 = pyfftw.interfaces.numpy_fft.fft(D1, dim * 2 - 1, axis=0, threads=nthread)
    #     end = time() - start
    #     break
    # print(end)
    # while True:
    #     start = time()
    #     _fft = pyfftw.builders.fft(D1, dim * 2 - 1, axis=0, overwrite_input=True, planner_effort='FFTW_MEASURE', threads=nthread)
    #     _C1 = _fft()
    #     end = time() - start
    #     break
    # print(end)
    # while True:
    #     start = time()
    #     c1 = np.zeros_like(D1[:-1, :])
    #     # c2 = np.zeros_like(D2)
    #     fft1 = pyfftw.builders.fft(D1, n=dim * 2 - 1, axis=0, planner_effort='FFTW_MEASURE', threads=nthread, avoid_copy=True)
    #     c1 = fft()
    #     end = time() - start
    #     break

    # Remove mirrored part
    # start = time()
    C = C[dim // 2 - 1 : -dim // 2]
    # print(time() - start)

    # Scale data with log modulus
    # start = time()
    scale = np.log(np.max(np.abs(C) + 1, axis=0) / dim)
    # print(time() - start)
    try:
        # start = time()
        C = C[..., :] / (np.amax(np.abs(C), axis=0) / scale)
        C[np.isnan(C)] == 0
        C[np.isinf(C)] == 0
        # print(time() - start)
    except RuntimeWarning:
        print("Hej")

    return C


def load_signals(edf_file, fs, cohort, encoding):

    # header = highlevel.read_edf_header(edf_file)
    header = mne.io.read_raw_edf(edf_file)

    # if cohort == 'jcts':
    temp_data, cFs, channel_labels = edf_read_fns[cohort](edf_file, fs)

    if encoding == 'cc':  # TODO: this is broken
        # Resampling data. Filter coefficients are pulled from MATLAB
        data = [[]] * temp_data.shape[0] if not isinstance(temp_data, list) else [[]] * len(temp_data)
        for idx, orig_fs in enumerate(cFs):
            if orig_fs != fs:
                data[idx] = signal.upfirdn(
                    filter_specs[str(fs)][str(orig_fs)]["numerator"],
                    temp_data[idx],
                    filter_specs[str(fs)][str(orig_fs)]["up"],
                    filter_specs[str(fs)][str(orig_fs)]["down"],
                )
                if fs == 100:
                    if (
                        orig_fs == 256 or orig_fs == 512
                    ):  # Matlab creates a filtercascade which requires the 128 Hz filter be applied afterwards
                        data[idx] = signal.upfirdn(
                            filter_specs[str(fs)]["128"]["numerator"],
                            data[idx],
                            filter_specs[str(fs)]["128"]["up"],
                            filter_specs[str(fs)]["128"]["down"],
                        )
            else:
                data[idx] = temp_data[idx]
    elif encoding == 'raw':
        # Resample data using polyphase filtering
        data = [[]] * temp_data.shape[0] if not isinstance(temp_data, list) else [[]] * len(temp_data)
        for idx, orig_fs in enumerate(cFs):
            if isinstance(temp_data[idx], np.ndarray):
                if orig_fs != fs:
                    data[idx] = signal.resample_poly(temp_data[idx], fs, orig_fs)
                else:
                    data[idx] = temp_data[idx]

    # Trim
    for idx in range(len(data)):
        # 30 represents the epoch length most often used in standard hypnogram scoring.
        if isinstance(data[idx], np.ndarray):
            rem = len(data[idx]) % (fs * 30)
            # Otherwise, if rem == 0, the following results in an empty array
            if rem > 0:
                data[idx] = data[idx][:-rem]

    # Select channels based on noise levels
    central_list = [0, 1]
    occipital_list = [2, 3]
    # Select Central channel, index 0 in meanV and covM
    keep_idx_central = get_quiet_channel([data[j] for j in central_list], fs, meanV[0], covM[0])
    # Select occipital channel, index 1 in meanV and covM
    keep_idx_occipital = get_quiet_channel([data[j] for j in occipital_list], fs, meanV[1], covM[1])
    # Select only kept channels
    data = np.concatenate(
        [
            data[central_list[keep_idx_central]][np.newaxis, :],
            data[occipital_list[keep_idx_occipital]][np.newaxis, :],
            data[-3:],
        ]
    )

    # else:
    #     ind = -np.ones(16, dtype=np.int32)

    #     # for i in range(16):
    #     #     if np.where(get_alternative_names(i, header["channels"]))[0].size > 0:
    #     #         ind[i] = int(np.where(get_alternative_names(i, header["channels"]))[0])
    #     for i in range(16):
    #         if np.where(get_alternative_names(i, header.ch_names))[0].size > 0:
    #             ind[i] = int(np.where(get_alternative_names(i, header.ch_names))[0])

    #     # This tests if any of the central, occipital, EOG or EMG channels are missing in the file
    #     testCentral = all(ind[[0, 2]] == -1) & (all(ind[[1, 3]] == -1) | all(ind[[8, 9]] == -1))
    #     testOccipital = all(ind[[4, 6]] == -1) & (all(ind[[5, 7]] == -1) | all(ind[[8, 9]] == -1))
    #     testEOG = all(ind[[10, 12]] == -1) & (all(ind[[11, 13]] == -1) | all(ind[[8, 9]] == -1))
    #     testEMG = all(ind[[14, 15]] == -1)
    #     if any([testCentral, testOccipital, testEOG, testEMG]):
    #         raise MissingSignalsError(os.path.basename(edf_file), header['channels'])
    #         # print(f'Wrong labels!: \n{header["channels"]}')
    #         # return None

    #     loaded = ind != -1  # [idx for idx in ind if idx != -1]

    #     temp_data, data_headers, file_header = highlevel.read_edf(edf_file, ch_nrs=list(ind[loaded]))
    #     loaded_channels = np.asarray(header["channels"])[ind[loaded]].tolist()

    #     # This tests for central left EEG
    #     if ind[1] != -1:
    #         c3_idx = np.where(ind[loaded] == ind[1])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[8] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[8])[0].item()
    #             print(f'Referencing {data_headers[c3_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[c3_idx] -= temp_data[ref_idx]
    #         elif ind[9] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[c3_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[c3_idx] -= temp_data[ref_idx]
    #         # else:
    #         #     raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         # print(f'Referencing {data_headers[c3_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #         # temp_data[c3_idx] -= temp_data[ref_idx]
    #     # This tests for right central EEG
    #     if ind[3] != -1:
    #         c4_idx = np.where(ind[loaded] == ind[3])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[9] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[c4_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[c4_idx] -= temp_data[ref_idx]
    #         elif ind[8] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[8])[0].item()
    #             print(f'Referencing {data_headers[c4_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[c4_idx] -= temp_data[ref_idx]
    #         # else:
    #         #     raise ReferencingError(os.path.basename(edf_file), header, ind[3])
    #         # print(f'Referencing {data_headers[c4_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #         # temp_data[c4_idx] -= temp_data[ref_idx]
    #     # This tests for left occipital EEG
    #     if ind[5] != -1:
    #         o1_idx = np.where(ind[loaded] == ind[5])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[8] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[8])[0].item()
    #             print(f'Referencing {data_headers[o1_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[o1_idx] -= temp_data[ref_idx]
    #         elif ind[9] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[o1_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[o1_idx] -= temp_data[ref_idx]
    #         # else:
    #         #     raise ReferencingError(os.path.basename(edf_file), header, ind[5])
    #         # print(f'Referencing {data_headers[o1_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #         # temp_data[o1_idx] -= temp_data[ref_idx]
    #     # This tests for right occipital EEG
    #     if ind[7] != -1:
    #         o2_idx = np.where(ind[loaded] == ind[7])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[9] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[o2_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[o2_idx] -= temp_data[ref_idx]
    #         elif ind[8] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[8])[0].item()
    #             print(f'Referencing {data_headers[o2_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[o2_idx] -= temp_data[ref_idx]
    #         # else:
    #         #     raise ReferencingError(os.path.basename(edf_file), header, ind[7])
    #         # print(f'Referencing {data_headers[o2_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #         # temp_data[o2_idx] -= temp_data[ref_idx]
    #     # This tests for left EOG
    #     if ind[11] != -1:
    #         eogl_idx = np.where(ind[loaded] == ind[11])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[8] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[8])[0].item()
    #             print(f'Referencing {data_headers[eogl_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[eogl_idx] -= temp_data[ref_idx]
    #         elif ind[9] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[eogl_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[eogl_idx] -= temp_data[ref_idx]
    #         # else:
    #         #     raise ReferencingError(os.path.basename(edf_file), header, ind[11])
    #         # print(f'Referencing {data_headers[eogl_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #         # temp_data[eogl_idx] -= temp_data[ref_idx]
    #     # This tests for right EOG
    #     if ind[13] != -1:
    #         eogr_idx = np.where(ind[loaded] == ind[13])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[9] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[eogr_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[eogr_idx] -= temp_data[ref_idx]
    #         elif ind[8] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[8])[0].item()
    #             print(f'Referencing {data_headers[eogr_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[eogr_idx] -= temp_data[ref_idx]
    #         # else:
    #         #     raise ReferencingError(os.path.basename(edf_file), header, ind[13])
    #         # print(f'Referencing {data_headers[eogr_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #         # temp_data[eogr_idx] -= temp_data[ref_idx]

    #     # if ind[14] != -1:
    #     if ind[14] != -1:
    #         emg_idx = np.where(ind[loaded] == ind[14])[0].item()
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[1])
    #         if ind[15] != -1:
    #             ref_idx = np.where(ind[loaded] == ind[9])[0].item()
    #             print(f'Referencing {data_headers[emg_idx]["label"]} to {data_headers[ref_idx]["label"]}')
    #             temp_data[emg_idx] -= temp_data[ref_idx]
    #         # print(f'Referencing {header["channels"][ind[14]]} to {header["channels"][ind[15]]}')
    #         # raise ReferencingError(os.path.basename(edf_file), header, ind[15])
    #     # return

    #     # Delete ref signals
    #     ref_idx = []
    #     if ind[8] != -1:
    #         ref_idx.append(np.where(ind[loaded] == ind[8])[0].item())
    #     if ind[9] != -1:
    #         ref_idx.append(np.where(ind[loaded] == ind[9])[0].item())
    #     temp_data = np.delete(temp_data, ref_idx, axis=0)
    #     data_headers = np.delete(np.asarray(data_headers), ref_idx).tolist()
    #     cFs = [dh["sample_rate"] for dh in data_headers]
    #     channel_labels = [dh["label"] for dh in data_headers]

    #     # Resampling data. Filter coefficients are pulled from MATLAB
    #     data = [[]] * temp_data.shape[0] if not isinstance(temp_data, list) else [[]] * len(temp_data)
    #     for idx, orig_fs in enumerate(cFs):
    #         if orig_fs != fs:
    #             data[idx] = signal.upfirdn(
    #                 filter_specs[str(fs)][str(orig_fs)]["numerator"],
    #                 temp_data[idx],
    #                 filter_specs[str(fs)][str(orig_fs)]["up"],
    #                 filter_specs[str(fs)][str(orig_fs)]["down"],
    #             )
    #             if fs == 100:
    #                 if (
    #                     orig_fs == 256 or orig_fs == 512
    #                 ):  # Matlab creates a filtercascade which requires the 128 Hz filter be applied afterwards
    #                     data[idx] = signal.upfirdn(
    #                         filter_specs[str(fs)]["128"]["numerator"],
    #                         data[idx],
    #                         filter_specs[str(fs)]["128"]["up"],
    #                         filter_specs[str(fs)]["128"]["down"],
    #                     )
    #         else:
    #             data[idx] = temp_data[idx]

    #     # Trim
    #     for idx in range(len(data)):
    #         # 30 represents the epoch length most often used in standard hypnogram scoring.
    #         rem = len(data[idx]) % (fs * 30)
    #         # Otherwise, if rem == 0, the following results in an empty array
    #         if rem > 0:
    #             data[idx] = data[idx][:-rem]

    #     # Select channels based on noise levels
    #     central_list = list(np.where(np.in1d(ind[loaded], ind[:4][loaded[:4]]))[0])
    #     occipital_list = list(np.where(np.in1d(ind[loaded], ind[4:8][loaded[4:8]]))[0])
    #     # Select Central channel, index 0 in meanV and covM
    #     keep_idx_central = get_quiet_channel([data[j] for j in central_list], fs, meanV[0], covM[0])
    #     # Select occipital channel, index 1 in meanV and covM
    #     keep_idx_occipital = get_quiet_channel([data[j] for j in occipital_list], fs, meanV[1], covM[1])
    #     # Select only kept channels
    #     data = np.concatenate(
    #         [
    #             data[central_list[keep_idx_central]][np.newaxis, :],
    #             data[occipital_list[keep_idx_occipital]][np.newaxis, :],
    #             data[-3:],
    #         ]
    #     )
    #     channel_labels = (
    #         [channel_labels[central_list[keep_idx_central]]]
    #         + [channel_labels[occipital_list[keep_idx_occipital]]]
    #         + channel_labels[-3:]
    #     )

    return data



def process_single_file(current_file, fs, seq_len, overlap, cohort, encoding="cc"):
    missing_hyp = []
    missing_sigs = []

    hyp = load_scored_data(current_file.split(".")[0], cohort=cohort)
    if hyp is None:
        raise MissingHypnogramError(os.path.basename(current_file))
        # return None, None, None, 1, None

    sig = load_signals(current_file, fs, cohort, encoding)
    # if sig is None:
    # print("Skipping due to missing signals")
    # return None, None, None, None, 1
    hyp = hyp[: len(sig[0]) // (fs * 30), :]

    # sig = signal.sosfiltfilt(sosH, sig)
    # sig = signal.sosfiltfilt(sosL, sig).astype(np.float32)
    # sig = sig.astype(np.float32)

    if encoding == "cc":

        label = np.repeat(hyp, 120, axis=0)
        # label = label.T.flatten()  # Why is this here...?

        # Filter signals
        wH = 0.2 / (fs / 2)
        wL = 49 / (fs / 2)
        bH, aH = signal.butter(5, wH, btype="high", output="ba")
        bL, aL = signal.butter(5, wL, btype="low", output="ba")
        sig = signal.filtfilt(bH, aH, sig, padlen=3 * (max(len(bH), len(aH)) - 1))
        sig = signal.filtfilt(bL, aL, sig, padlen=3 * (max(len(bL), len(aL)) - 1)).astype(
            np.float32
        )  # These should match MATLAB output

        # Do encoding
        encodings = []
        for ch, cc_size in zip(sig, cc_sizes):
            encodings.append(encode_data(ch, ch, cc_size, cc_overlap, fs))
        encodings.append(encode_data(sig[2], sig[3], cc_sizes[2], cc_overlap, fs))

        # Trim excess
        C = np.concatenate([enc[:, : np.size(encodings[-1], 1)] for enc in encodings])
        label = label[: C.shape[1]]
        if label.shape[1] > 1:
            delete_idx = []
        else:
            delete_idx = np.where(label == 7)[0]
        C = np.delete(C, delete_idx, axis=1)
        label = np.delete(label, delete_idx, axis=0)
        if hyp.shape[1] > 1:
            delete_idx = []
        else:
            delete_idx = np.where(hyp == 7)[0]
        hyp = np.delete(hyp, delete_idx, axis=0)

        # Design labels
        labels = np.zeros((5,) + label.shape).astype(np.uint8)
        for j in range(5):
            labels[j, label == j + 1] = 1
        # index = rolling_window_nodelay(np.arange(C.shape[1]), seq_len, seq_len - overlap).T
        index = skimage.util.view_as_windows(np.arange(C.shape[1]), seq_len, seq_len - overlap)
        M = np.stack([C[:, j] for j in index], axis=0)
        L = np.stack([labels[:, j] for j in index], axis=0)

        # Adjust weights depending on stage
        if hyp.shape[1] == 1:
            hyp = np.repeat(hyp, 2)
            mask = np.zeros(hyp.shape)
            dhyp = np.abs(np.sign(np.diff(hyp)))
            mask[: len(dhyp)] = mask[: len(dhyp)] + dhyp
            mask[1 : len(dhyp) + 1] = mask[1 : len(dhyp) + 1] + dhyp
            mask = (1 - mask).astype(np.float32)
            weight = np.zeros(hyp.shape)
            weight[hyp == 1] = 1.5
            weight[hyp == 2] = 2
            weight[hyp == 3] = 1
            weight[hyp == 4] = 2.5
            weight[hyp == 5] = 2
            weight *= mask
            weight = np.repeat(weight, 60)

            W = np.stack([weight[j] for j in index], axis=0)
            Z = None
        else:
            W = None
            Z = None

    elif encoding == "raw":

        # Filter signals
        eegFilter = signal.butter(2, [0.3, 35], btype="bandpass", output="sos", fs=fs)
        emgFilter = signal.butter(4, 10, btype="highpass", output="sos", fs=fs)
        sig[:4] = signal.sosfiltfilt(eegFilter, sig[:4])
        sig[-1] = signal.sosfiltfilt(emgFilter, sig[-1])
        sig = sig.astype(np.float32)
        # fmt: off

        # Trim excess
        C = np.stack([rolling_window_nodelay(s, 30 * fs, 30 * fs) for s in sig])

        # C = np.delete(C, np.where(hyp[:, 0] == 7)[0], axis=-1)
        # hyp = np.delete(hyp, np.where(hyp[:, 0] == 7)[0], axis=0)

        # Design labels
        labels = np.zeros((5, hyp.shape[0], hyp.shape[1])).astype(np.uint32)
        for j in range(5):
            labels[j, hyp == j + 1] = 1

        # Mask vector to account for unknown stages (7), or anything else that should be excluded in the loss calculations
        Z = np.full(hyp.shape, False, dtype=bool)
        Z[np.where(hyp == 7)] = True  # Unknown stage 7

        # Create a rolling window index vector (for overlapping windows)
        # index = skimage.util.view_as_windows(np.arange(C.shape[-1]), seq_len, seq_len - overlap)
        index = rolling_window_nodelay(np.arange(C.shape[-1]), seq_len, seq_len - overlap).T

        # Create stacked arrays
        M = np.stack([C[:, :, j] for j in index], axis=0)
        M = np.swapaxes(M, 2, 3).reshape((M.shape[0], M.shape[1], -1))
        L = np.stack([labels[:, j] for j in index], axis=0).repeat(30, axis=2)  # (Number of sequences, number of classes, hypnogram value for each second in sequence)
        Z = np.stack([Z[j] for j in index], axis=0)

        W = None

        # fmt: on
    return M, L, W, Z, None, None


def process_data(args):

    random.seed(42)
    np.random.seed(42)

    data_stack = None

    # If multiple data folders are given (comma-delimiter)
    data_dirs = args.data_dir.split(",")

    fs = args.fs
    save_dir = args.save_dir
    seq_len = args.seq_len
    overlap = args.overlap
    encoding = args.encoding

    # Make a list of all the files by looping over all available data-sources
    listF = []
    for directory in data_dirs:
        # random.seed(12345)
        listT = sorted(glob(os.path.join(directory, "*.[EeRr][DdEe][FfCc]")))
        listF += listT

    not_listed = []
    listed_as_train = []
    listed_as_test = []
    something_wrong = []
    missing_hyp = []
    missing_sigs = []
    for current_file in listF:
        current_fid = os.path.basename(current_file).split(".")[0]
        if df.query(
            f'ID == "{current_fid}"'
        ).empty:  # The subject is not in the overview file and is automatically added to the train files
            not_listed.append(current_file)
        elif (df.query(f'ID == "{current_fid}"')["Sleep scoring training data"] == 1).bool():
            listed_as_train.append(current_file)
        elif (df.query(f'ID == "{current_fid}"')["Sleep scoring test data"] == 1).bool():
            listed_as_test.append(current_file)
            continue
        else:
            print(f"Hmm... Something is wrong with {current_file}!")
            something_wrong.append(current_file)
            continue
    list_files = listF
    listF = not_listed + listed_as_train
    # random.seed(12345)
    random.shuffle(listF)

    save_names = [os.path.join(save_dir, str(np.random.randint(10000000, 19999999)) + ".h5") for _ in range(1000)]

    # Run through all files and generate H5 files containing 300 5 min sequences
    i = -1
    pbar = tqdm(range(len(listF)))
    for i in pbar:
        # if i < 6:
        #     continue
        # while True:
        # i += 1
        if i < len(listF):
            current_file = listF[i]

            # if os.path.basename(current_file).split('.')[0] != 'A1039_3 164125':
            #     continue

            pbar.set_description(current_file)

            M, L, W, is_missing_hyp, is_missing_sigs = process_single_file(current_file, fs, seq_len, overlap, encoding)
            if is_missing_hyp:
                missing_hyp.append(current_file)
                continue
            elif is_missing_sigs:
                missing_sigs.append(current_file)
                continue

            if data_stack is None:
                data_stack = M
                label_stack = L
                weight_stack = W
            else:
                data_stack = np.concatenate([data_stack, M], axis=-1)
                label_stack = np.concatenate([label_stack, L], axis=-1)
                weight_stack = np.concatenate([weight_stack, W], axis=-1)

        if data_stack.shape[-1] > 900 | (i == len(listF) - 1 & data_stack.shape[-1] > 300):

            if not os.path.exists(save_dir):
                os.mkdir(save_dir)

            # Shuffle the data
            ind = np.random.permutation(data_stack.shape[-1])
            data_stack = data_stack[:, :, ind]
            label_stack = label_stack[:, :, ind]
            weight_stack = weight_stack[:, ind]

            # Save to H5 file
            save_name = save_names.pop(0)
            with File(save_name, "w") as f:
                f.create_dataset("trainD", data=data_stack[:, :, :300])  # (data_stack.shape[0], seq_len, 300))
                f.create_dataset("trainL", data=label_stack[:, :, :300])  # (data_stack.shape[0], seq_len, 300))
                f.create_dataset("trainW", data=weight_stack[:, :300])  # (data_stack.shape[0], seq_len, 300))

            # Remove written data from the stack
            data_stack = np.delete(data_stack, range(300), axis=-1)
            label_stack = np.delete(label_stack, range(300), axis=-1)
            weight_stack = np.delete(weight_stack, range(300), axis=-1)

    if not os.path.exists("./txt"):
        os.mkdir("./txt")
    with open("txt/not_listed.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", not_listed))
    with open("txt/listed_as_train.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", listed_as_train))
    with open("txt/listed_as_test.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", listed_as_test))
    with open("txt/something_wrong.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", something_wrong))
    with open("txt/missing_hyp.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", missing_hyp))
    with open("txt/missing_sigs.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", missing_sigs))
    with open("txt/processed_files.txt", "w") as f:
        f.writelines(map(lambda x: x + "\n", listF))

    return 0


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--data_dir", type=str, required=True)
    parser.add_argument("--save_dir", type=str, required=True)
    parser.add_argument("--fs", type=int, default=100)
    parser.add_argument("--seq_len", type=int, default=1200)
    parser.add_argument("--overlap", type=int, default=400)
    parser.add_argument("--encoding", type=str, choices=["cc", "raw"], default="cc")
    args = parser.parse_args()

    if args.encoding == "raw":
        args.seq_len = 10
        args.overlap = 5

    process_data(args)
